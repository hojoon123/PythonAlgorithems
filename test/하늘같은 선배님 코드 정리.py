'''

tmp => 점수 / 보너스 /옵션 str로 입력 받기
splitScore 함수 호출


--------- def splitScore() ---------------
[ tmp리스트의 0번째 자리에 있는 숫자, '','' ]
# 선배님 코멘트: tmp[0] 번째 자리에 있는 숫자 즉 '0123456789' 중에 하나!
# 만약 10의 경우엔 어떻게 될까? 1이 들어가게 됩니다!


for i ~~ (1, len(tmp))  => 1 ~ tmp의 길이까지 
# 선배님 코멘트 : 1로 한 이유는 알고 계신가요? if tmp[i] 가 num_li 안에 있는지 체크할 때 최초의 숫자에서 통과 되기 때문입니다
# 그래서 최초의 숫자가 통과하는 걸 방지하기 위해서 미리 tmp[0]을 넣어주고 1부터 시작합니다!

if tmp[i]가 num_li 안에 있어?
    if tmp[i-1]이 1이 아니야?    -> 만약 [i]가 num_li안에 있으면서 [i-1]이 1이라면 10
        idx에 1을 더해              # 선배님 코멘트 : 굿 10의 경우 처음에 1을 넣고 0에서 또 if가 통과되는데
                                  #  해당 코드가 없으면 0은 다음 인덱스로 넘어가버리죠 방지하기 위한 코드


if문 끝나고? DT[idx]에 tmp[i]를 더해
# 숫자를 만나기 전까진 해당 인덱스에 계속 이후의 정보를 넣습니다 10S*3T 라면 10S*까지 넣죠.
# 그리고 위의 if문에서 숫자를 만나면 idx를 증가시켜서 다음 인덱스에 숫자를 집어넣습니다!

DT를 리턴해

==> DT 리스트에 점수를 기준으로 나눠서 계속 추가? 변경? 암튼 나눠짐
# 이 함수는 한 줄의 문자열로 입력받은 점수 시스템을 개별로 분할하는 함수였습니다!
------------------------------------------------------


dividedDT = DT   
-> DT = ['1S','2D*','3T']
calScore(['1s','2D*','3T']) 넘겨?주기


----------- def calScore(dividedDT) -------------

for i in dividedDT    i => lS / 2D* / 3T  이렇게 순서대로 돌겠지?
# 선배님 코멘트: 네 맞습니다 순서대로 들어갑니다. 위와 같은 의문은 print(i) 등 직접 출력을 해봄으로써 확인하시면서 합시다.(혹시 그렇게 하셨나요?)

i[1]가 0이 아니야?
    point 리스트에 int(i[0])을 append     -> i[0]은 점수

else => i[1] == '0'이야?   -> 10D 처럼 점수가 10점일 경우
    point 리스트에 10을 append   -> 10점이니까

# 선배님 코멘트: 굿

point => [1,2,3]이 담겨?있음

# 선배님 코멘트: 굿

for score in dividedDT   score => lS / 2D* / 3T  이렇게 돌겠지?

if score[1]이 'D'야?
    point[idx] ** 2   -> 2제곱

elif score[1]이 'T'야?
    point[idx] ** 3    ->3제곱

score가 '1S' 일 때는 다 넘어감 => S는 해당사항 없음
# 선배님 코멘트: 굿

if score[-1]이 '*#' 안에 있어?    => 옵션이 있는지 없는지 검사 [-1]은 제일 마지막 자리니까 옵션 확인 b
    if score[2]가 '*' 이야?     (선배님한테 물어보기...)  if score[-1] == '*': 이렇게 하면 안되나요..?
    # ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ해도 됨 내가 처음에 0점 초과 10점 미만인 줄 알고 len(3)으로 해두고 쓰다가 헷갈린듯
    # 오히려 2면 틀린 것 같아요! 10S*의 경우 2에 S가 오니까 이건 제 실수입니다ㅎㅎㅎㅎ 예제만 통과하고 방심함ㅠ
    # 쏘리쏘리 이런 걸 찾아내다니 열심히 했네요! :) 
    
        if idx가 0이 아니야?   => 0이 아니라면 전 점수, 현재 점수 *2
            point[idx - 1]에 2를 곱해       바로 전 점수와 현재 점수 *2
            point[idx]에 2를 곱해
        else  => 0 이야?        => 0이면 현재 점수
            point[idx]에 2를 곱해
            
        # 선배님 코멘트: 해당 코드의 if문은 idx로 첫번째 점수니? 라고 묻는거죠! 적어둔 대로 첫번째가 아니라면 이전과 현재
        # 첫번째라면 현재점수만! 잘 적어두셨네요 :)

    else =>  '#' 이야?
            point[idx] = -point[idx]        현재 점수 마이너스
    # 끗

if가 끝나고? idx에 1을 더해
# 그렇죠 현재 인덱스 점수 산정을 끝내고 다음 인덱스 점수 산정을 해주어야 하니까요!
# idx에 1을 더하지 않고도 할 수 있는데 그렇게 하려면 최초에 dividedDT를 score로 하나씩 떼는게 아니라
# range(len(dividedDT) 그리고 score 자리에 인덱스 번호를 사용하면 됩니다.
# 다른 언어(자바, c++ 등등) 에서는 위와 같이 합니다. 하지만 파이썬은 예외죠. 인덱스번호를 이용해서
# 값을 받으려고 하면 어쩔 수 없이 코드가 너무 더러워 집니다. 그러면 가독성이 정말 떨어지죠!
# 저희는 적절한 변수명, 적절한 함수명, 짧은 코드 등을 통해서 코드를 이쁘게! 즉 가독성이 좋게 작성하고 싶어요!
# 그래서 dividedDT 그대로 for문 돌려서 인덱스 번호가 필요한 자리만 사용하기 위해 idx + 1 작업을 해주었습니다ㅎㅎ

point  -> [2,8,27]
sum(point) 리턴해  => sum([2,8,27]) 리턴해
# 여기는 점수 계산하는 거 자리마다 확인하기 위한 자리였죠! 출력은 지우셔도 됩니다!
----------------------------------------------------------

출력해~~!!

# 고생하셨어요 :)
'''
https://dev-dain.tistory.com/113 자세한 설명

선택 정렬(selection sort)
시간복잡도 O(n^2) 4순위
실제 교환하는 시간복잡도는 O(n)이다
값의 위치를 바꾸는 식
이중 for 루프
예제221110_BJOCp_10 / BJO2750.py 


삽입 정렬(insertion sort)
평균적인 시간복잡도는 O(n^2) 4순위
이중 for 루프 혹은 for 루프와 while 루프
key 값을 기준으로 왼쪽 값 보다 key 값이 더 작은가?
key 값을 왼쪽에 있는 자기 보다 큰 값 앞으로 이동
그렇기에 정렬이 어느 정도 진행되어 있다면 좋지만,
역으로 정렬되어 있는 상황일 때 while을 계속해서 돌아야 하기 때문에
매우 비효율적
예제221110_BJOCp_10 / 1BJO2750.py


거품 정렬(bubble sort)
시간복잡도는 O(n^2) 4순위
리스트의 이웃 요소와 비교(인접한 두 항목을 비교)해서
이웃 요소와 정렬이 안 되어 있을 경우 서로 자리를 바꿔주는 방식의 정렬
옆의 원소랑 비교해서 자리를 바꿈 i값의 증가에 따라 2번에 있던게
점점 끝으로 가는 형식임
솔직히 선택 정렬이랑 또이또이
예제221110_BJOCp_10 / 2BJO2750.py


병합 정렬(merge sort)
시간복잡도는 O(nlogn) 1순위
재귀 방식을 이용해서 리스트의 요소들을 정렬하는 방식
리스트의 중간 인덱스를 기준으로 좌우로 그룹을 나눠 계속 쪼개나가 정렬
분할 정복(divide & conquer) 방식
어떤 문제가 있을 때 그 문제를 작은 단위의 문제로 쪼개서 
더 이상 쪼갤 수 없을 때까지 쪼갠 다음 작아진 문제를
해결해서 다시 위로 거슬러 올라가는 방식
예제221110_BJOCp_10 / 3BJO2750.py


퀵 정렬(Quick sort)
시간 복잡도는 보통 O(nlogn)
최악의 경우에는 O(n^2)
병합 정렬처럼 재귀 함수를 이용하여 정렬
피벗값(pivot)을 두고 그 피벗값과 다른 값들을 
비교해 값들을 바꿔나가는 방식
예제221110_BJOCp_10 / 4BJO2750.py

카운팅 정렬(Counting sort)
 O(n + k)의 시간복잡도
k는 정렬을 수행할 배열의 가장 큰 값
k가 n보다 작다면 정렬의 수행시간은 O(n)
무한대로 크다면 정렬의 수행시간도 무한대
장점 입력 값의 수가 작으면 매우 빠르다
예를 들어 10000개를 입력 받아도 10이하의 작은 수라면 굉장히 빠르다
반면 2개를 입력 받아도 입력값이 2, 1020304 이러면 2개 모두 1020304만큼
카운팅을 해줘야해서 겁나 오래걸린다
예제221111_BJOCp_10 / BJO10989.py
예제221111_BJOCp_10 / 1BJO10989.py

내장 함수 list.sort() / sorted()
원본을 유지해야 할 때에는 sorted() 함수
다른 자료형을 정렬할 때에는 sorted() 함수
원본이 필요 없을 때에는 sort() 함수
list를 이용할 때에는 sort() 함수
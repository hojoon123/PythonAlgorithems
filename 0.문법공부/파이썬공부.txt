문자열
"안녕하세요 {변수} 입니다.".format({변수}="강호준")
f"안녕하세요 {변수}입니다."

동일한 효과

a= "%0.4f" % 3.34523
0은 간격 4는 4자리까지


변수.함수()


딕셔너리 
키 변수

a= {1: 'a'}
a['name'] = "강호준"

딕셔너리 순서 x
del a[key] 이렇게 해야 없어짐ㅇㅇ

키리스트

a={1: '파랑구름', 2: '강호준', 3: '하스'}

a.keys() 키만 뽑을 수 있음
a.values() 변수만 뽑을 수 있음
a.get(4,'없음') none 값이 나옴
없음 값이 나옴 ㅇㅇ


집합 중복 허용 x
순서가 없음

s1= set([1,2,3])
s1 = {1,2,3}
둘이 똑같음
데이터 쪽에서 다룸 자동화도 충분히 다룰만 하죠

list명 = list(여러가지) 이러면 리스트화
sfdf = set(여러가지) 이러면 집합
집합으로 바꿔서 중복 없애고 리스트로 다시 바꾸는 등 작업도 함 ㅇㅇ


교집합 차집합 합집합

s1 = set ~~`
s2 = set ~~
s1 & s2 
s1, s2의 교집합 찾기
매우 유용
와 원래 이거 반복문 줜나게 쓰면서 찾는데 매우 편하죠
s1.intersection(s2)로도 사용 가능 걍 &쓰자

합집합 | 쓰면 끝 
union 유니온이 합집합이구나

차집합 
걍 - 끝


뭐 하기 싫으면 pass 넣으면 됨 이거 굉장하네


함수 / 매개변수
매개변수 *args 이렇게 넣으면 매개변수 몇 개든 가능

매개변수 **kwargs 딕셔너리 형태로 여러가지 값을 받을 수 있음

이거 되게 좋네
if k== name 
print 이름은 + k 이런 식으로 넣고 걍 돌려버리면 되니까 좋다

return 값을 2개 넣으면 튜플 형태로 들어감
값 자체는 1개임 이렇게 여러개 리턴하고
사용할 때 함수(매개변수)[0] 이렇게 하면 0번쨰 리턴 1번쨰 리턴
가능 매우 좋은데?


람다
lambda 매개변수1, 매개변수2: 매개변수1+매개변수2
=
def 함수(매개변수1,매개변수2):
	retrun 매개변수1+매개변수2


파일
with open("경로 파일명","여는방식") as 변수:
	이렇게쓰면됨


클래스
class 클래스명:
	def __init__:  이닛 저거는 시작할 때 무조건 저걸 처음 실행해라
		    라는 뜻임 이거 되게 중요하죠.(생성자)
		self.result = 0
self 가 내가 클래스 사용할 때 넣는 최초의 객체를 넣는 곳
setdata(self, first, second):
a.setdata(1,2)
a,1,2 순으로 들어감

a = 클래스명()
a.setdata(1,2) 이런 식으로 사용해야함

상속 
class 자식클래스명(부모클래스명):

오버라이딩 덮어쓴다는 뜻임



모듈
모듈 미리 만들어놓은 파일
from 파일명 import 원하는 함수, 클래스 등등
import 파일명 하면 전부 가져옴

if __name__ == "__main__" 이렇게 하면 모듈을 사용할 때
import 하는 곳에서 if 문 작동 x

만약에 불러오려는 모듈이 다른 경로에 있을 때
import sys
sys.path.append("경로")
적어야 불러올 수 있음


패키지는 모듈을 여러개 모아놓은 것

패키지에서 __init__.py 라는 제목이면
패키지 내에서 패키지 관련 설정을 담당하는
게임으로 치면 gameManager와 동일한 기능이죠

패키지는 불러올 때 
import 폴더.폴더.파일 이런 느낌으로 쓸 수 있음
함수를 쓸 땐
폴더.폴더.파일.함수() 이렇게 써야 됨 좀 번거롭네?
그래서 from을 써라 ㅇㅇ
from 폴더.폴더 import 파일
파일.함수() 이렇게 쓰면 됨 넘넘 편하죠
파일명도 입력하기 귀찮잖아
from 폴더.폴더 import 파일 as 임의변수
이렇게 쓰면 임의변수.함수() 이렇게만 쓰면 됨 넘넘 편해

*표가 싹 다 불러와라 임
import *
근데 그냥 쓰면 오류가 나고 이걸 쓰려면
패키지의 init에 __all__ =['파일명', '파일명'] 이런 식으로
제작자가 미리 정의 해놔야함.

..이 상대 기준 이전 폴더
from ..현재 주소 import 파일
근데 뭐 이해는 함 근데 솔직히 안 쓸듯 패키지나 라이브러리를 만드는
사람이 아닌 이상

예외처리

try:
오류가 발생할 수 있는 구문
except Exception as e:
오류 발생
else:
오류 발생하지 않음
finally:
무조건 마지막에 실행

try로 파일 오픈 만약 오픈 할 파일이 없으면 
except Exception(오류명) as e 이런 거 써서 만들어버리면 좋죠
Exception이 모든 오류의 부모님
근데 보통 if 로 먼저 찾고 없으면 만드는 식으로 보통 쓰죠
이건 그냥 다른 상황에서 써야할 듯

예외처리는 try로 시작해서 else면 오류 안 났을 때 실행 finally 는 마지막에
무조건 실행 이런 느낌으로 자주 쓸 수는 있겠네

보통 언제 쓰냐 데이터베이스 같은 거 서버 끊길 수도 있으니까
서버 끊기면 뭐 ㅈ될수도 있으니까 서버가 끊기거나 그럴 때 오류가
나오면 어떻게 처리해라 이런 식으로 사용하기도 한다고 하네요.

일부러 오류 발동 시키기 
raise 오류명
이걸 왜 쓰냐 부모클래스에서 자식클래스로 
변경을 원하는 함수가 있을 때 사용함
예를 들어 fly 라는 함수를 자식들 마다 다르게 사용하게 하고싶다
독수리(자식)과 참새(자식)의 속도는 다를텐데, 만약에 부모클래스와
완전히 동일해버리면 오류가 발생하니까 일부러 오류를 발생시켜서
무조건 변경하게 만드는 것

외장함수 줜나게 쎈거 많네잉
웹브라던가 타임 랜덤 등등 되게 자주 쓰죠잉




정규표현식
문자열의 규칙을 찾아서 어떤 문제를 해결할 때 사용

문자 클래스
[abc]
abc를 그냥 내가 적어놓은 객체에서 찾는 거
abc 중 아무거나 들어가면 매치

Dot(.)
a.b
a b 사이에 어떠한 문자라도 있어야만 매치

반복(*)
ca*t 
ca랑 t 사이에 몇개가 있든 상관 없이 매치
crerert 처럼 a가 없어도 0번 반복이라 매치라 침

반복(+)
ca+t 
ct같이 사이에 뭐가 없으면 매칭 x
a가 무조건 1개 이상 있어야 매치

반복( {m,n}, ? )

ca{2}t
이렇게 되면 a가 2일 때만 매치
ca{2,5}t
이렇게 콤마가 들어가면
2이상 5이하에서 매치

ab?c
?=={0,1} 과 같음
abc 매치
ac 매치
abbc 비매치

import re
객체1 = re.compile('[a-z]+')
이런 식으로 사용 a-z까지 문자열이 + 1번 이상 반복되면 ㅇㅇ 이라는 뜻

객체2=객체1.match('python')
이런 식으로 쓰면 됨
매치가 됐는지 체크하는 함수임
여기서 만약
3python이면 none 출력

search는 일치하는 구문을 봤을 때 match

findall 일치하는 걸 찾아서 리스트로 리턴

finditer iterator 형식으로 매치되는 문자열을 하나씩 리턴 박음

group() 매치 문자열 리턴
start() 매치 문자열 시작 위치 리턴
end() 매치 문자열 끝 위치 리턴
span() 매치 문자열 (시작,끝) 튜플 리턴

옵션으로 re.S 줄바꿈까지 포함

re.I 대소문자 무시

re.X 공백제거 
솔직히 정규표현식 한 줄로 적어놓으면 ㅈㄴ파악안되자늠
이거 쓰면 알아보기 쉽게 내가 공백 늘려서 적어도 공백 없는 걸로
인식해줘서 좀 더 편하게 사용가능

re.M 각 라인 마다 처음으로 인식시킴
^ 맨처음이라는 뜻
python 공백 단어 반복 이렇게 문자열도 설정 가능함
("^python\s\w+", re.M)     re.M은 멀티라인의 약어 

r'\\문자열'
이렇게 적으면 백슬레시 문제 해결
백슬레시 두개를 넣고 싶으면
\\\\문자열 이딴식으로 넣어야 하는데 개지랄이니까
r'\\문자열' 라고 하면 백슬레시 그냥 없는 거 침
로우스트링이래
	

메타 문자

|
'문자열 | 문자열'
or로 인식함  둘 중 하나 

^ 맨 처음을 의미

\b 공백을 의미

grouping()

'(ABC)+' 이게 그루핑 ABCABC

r"(\w+)\s+\d+[-]\d"
문자열(그룹) 공백 숫자 - 숫자 라는 의미
객체2.group(1) 이렇게 하면
첫번째 그룹인 문자열과 매치

\1 그루핑의 결과를 \1 자리에 써줌
그룹이 반복되는 것을 잡아냄 

그루핑된 문자열에 이름 붙이기
(?P<name>\w+)
이렇게 그루핑 했을 때
불러올 때 
객체2.group("name") 이런 식으로 불러오기 편함

전방탐색 : 긍정형 (?=)
(".+(?=문자열)")
검색 조건에는 포함되나 결과에 포함 x

부정형 (?!)
".*[문자열1](?!문자열2\).*문자열2의마지막거"
이렇게 하면 문자열2가 포함된 거 제외하고 매치

문자열 바꾸기 sub

p= re.compile('(문자열1 | 문자열2 | 문자열3)')
p.sub('문자열4', '장문의 메세지')
장문의 메세지 내부의 문자열123을 문자열4로 바꿔라 라는 뜻

Greedy / Non-Greedy
('<.*>').group() 이게 Greedy
<> 들어간 거 전부 다 가져옴
('<.*?>').group() 이게 논그리디 
첫번째꺼만 가져옴

이게 겁나 간단한 거임
물론 어렵진 않음 그냥 개념을 채웠따고 생각함
근데 하기 싫을지도??


나 문자열 / 정규표현식 약함

